## Εργασία 2 - Φοιτητές: Χωραφάς Χρήστος(8718)/Φάββας Αντώνης(8675), Ομάδα 33

## <pre>Βήμα 1)</pre>  


<pre><b>Ερώτημα 1</b></pre>  <br>
  1. _`i_cache_size : 32768`_  
  2. _`i_cache_assoc : 2`_  
  3. _`d_cache_size : 65596`_  
  4. _`d_cache_assoc : 2`_  
  5. _`l2_size : 2097152`_    
  6. _`l2_assoc : 8`_    
  7. _`cache_line_size : 64`_  
  
   <pre> Παρατήρηση: Για όλα τα benchmarks οι τιμές των διαφόρων παραμέτρων είναι ίδιες (default τιμές).</pre>  

   
   <br><br> 
<pre><b>Ερώτημα 2</b></pre>  <br>
_Benchmark 401_:  
  1. _`sim_seconds : 0.082631`_  
  2. _`CPI : 1.652621`_  
  3. _`i_misses : 0.000051`_  
  4. _`d_misses : 0.015205`_  
  5. _`l2_misses : 0.281779`_    
    <br>
    
_Benchmark 429_:  
  1. _`sim_seconds : 0.120773`_  
  2. _`CPI : 1.207734`_  
  3. _`i_misses : 0.01037`_  
  4. _`d_misses : 0.001938`_  
  5. _`l2_misses : 0.110032`_    
    <br>
    
_Benchmark 456_:  
  1. _`sim_seconds : 0.058129`_  
  2. _`CPI : 1.162574`_  
  3. _`i_misses : 0.000186`_  
  4. _`d_misses : 0.001673`_  
  5. _`l2_misses : 0.086262`_    
    <br>
    
_Benchmark 458_:  
  1. _`sim_seconds : 0.514664`_  
  2. _`CPI : 10.293277`_  
  3. _`i_misses : 0.000019`_  
  4. _`d_misses : 0.122943`_  
  5. _`l2_misses : 0.999984`_    
    <br>
    
_Benchmark 470_:  
  1. _`sim_seconds : 0.174660`_  
  2. _`CPI : 3.493201`_  
  3. _`i_misses : 0.000103`_  
  4. _`d_misses : 0.060970`_  
  5. _`l2_misses : 0.999940`_  
    
    Περιγραφή: Γενικός κανόνας είναι ότι όταν έχουμε μεγάλο αριθμό Misses στις διάφορες μνήμες 
    (i_cache, d_cache, l2_cache) έχουμε και μεγάλο CPI, το οποίο συνεπάγεται σε χειρότερο (μεγαλύτερο) χρόνο εκτέλεσης 
    της προσομοίωσης του benchmark. Συγκεκριμένα στο παράδειγμα μας το benchmark 458 έχει μεγάλο αριθμό Misses, κάτι το οποίο 
    συνεπάγεται μεγάλο CPI και άρα μεγάλο χρόνο εκτέλεσης της προσομοίωσης. Αντίθετα, το benchmark 456 έχει 
    τον μικρότερο αριθμό Misses σε όλες τις μνήμες, και ως συνέπεια αυτού χαρακτηρίζεται από το μικρότερο CPI και άρα τον καλύτερο 
    (μικρότερο) χρόνο προσομοίωσης.
    
   <br><br>
<pre><b>Ερώτημα 3</b></pre>  <br>  

Για όλα τα benchmarks ισχύει:  
  1. _`--cpu-clock=2GHz : system.clock = 1000`_  
  2. _`--cpu-clock=2GHz : system.cpu.clock = 500`_ 
  3. _`--cpu-clock=1GHz : system.clock = 1000`_  
  4. _`--cpu-clock=1GHz : system.cpu.clock = 1000`_  
  
<pre>  Και στις 2 περιπτώσεις τα δίαφορα μέρη του συστήματος χρονίζονται στο 1GHz. Ωστόσο οι πυρήνες και οι 
διάφοροι επεξεργαστές που ενδεχομένως να προστεθούν στο σύστημα χρονίζονται στα 2GHz (Α περίπτωση) και 
στο 1GHz (Β περίπτωση) αντίστοιχα. Επαλήθευση αυτών των παρατηρήσεων αποτελούν αυτά τα κομμάτια κώδικα 
από το .json αρχείο (A περίπτωση) : 
  
  "name": "cpu_clk_domain",                               
            "clock": [
                500
            ],  

  "name": "clk_domain", 
            "clock": [
                1000
            ], </pre>
     
     
<pre>  Όσον αφορά το scaling πρέπει να αναφέρουμε ότι στις μικρές συχνότητες υπάρχει αρκετά καλό scaling. 
Ωστόστο όσο αυξάνουμε την συχνότητα του επεξεργαστή τόσο μικραίνει ο ρυθμός με τον οποίο μειώνεται ο χρόνος
εκτέλεσης της προσομοίωσης. Αυτό συμβαίνει γιατι ο επεξεργαστής είναι συνήθως αρκετά πιο γρήγορος απο τα 
υπόλοιπα στοιχεία του συστήματος, συνεπώς αναγκάζεται να περιμένει. Στα πλαίσια αυτής της λογικής, ένας 
επεξεργαστής των 8GHz δεν σημαίνει ότι θα έτρεχε στο μισό χρόνο το ίδιο πρόγραμμα, που θα έτρεχε ένας άλλος 
επεξεργαστής των 4GHz. Άρα δεν υπάρχει τέλειο scaling. </pre>
   <br><br>  
     
## <pre>Bήμα 2)</pre>  

<pre>  Τα γραφήματα υπάρχουν στον φάκελο task2/graphs. Στα διάφορα γραφήματα ο άξονας των x παρέχει μια 
εικονική αρίθμηση, καθώς οι τιμές του αξονα αυτού για κάθε καμπύλη του γραφήματος είναι διαφορετικές. 
Αναλυτικότερα, για το l1i_size και l1d_size, οι τιμές για x = 1 μέχρι x = 8 αντιστοίζονται σε τιμές απο 
2 μεχρι 256Kb. Επιπλέον, για τα l1i_assoc, l1d_assoc και l2_assoc οι τιμές x = 1 μέχρι x = 5 αντιστοιχίζονται
σε τιμές απο 1 μέχρι 16. Ακόμα, για το l2_size οι τιμές του άξονα x αντιστοιχίζονται από 2 μέχρι 4096Kb και όσον 
αφορά την τελευταία παράμετρο cache_line οι τιμές του x άξονα αντιστοιχίζονται από 32 μέχρι 1024Kb. Να σημειώσουμε 
ότι όλες οι ενδιάμεσες τιμές του x αποτελούν δυνάμεις του 2. 
  
  Για το benchmark 401 οι μεταβλητές που παίζουν σημαντικό ρόλο στην ελαχιστοποίηση του CPI 
είναι το l2_size και το l1d_size, για το οποίο μάλιστα έχουμε και το ελάχιστο CPI 
(βέλτιση απόδοση CPI = 1.589011). 

  Για το benchmark 429 μέσα από το αρχείο stats.txt παρατηρούμε ότι όσο αυξάνεται το l1i_size τόσο 
μειώνεται το i_miss rate και τόσο μικρότερο CPI έχουμε. Το ίδιο ακριβώς ισχύει και για l1d_size. Επίσης 
βλέπουμε ότι βέλτιστη απόδοση CPI = 1.080834 δίνει το cache_line = 256Kb και άρα τελικά και οι τρεις 
μεταβλητές διαδραματίζουν σημαντικό ρόλο στην απόδοση του συστήματος.

  Για το benchmark 456 η αύξηση των l1i_size, l1d_size και l2_size έχει ως αποτέλεσμα την μείωση του 
ποσοστού miss rate σε αυτές και την βελτιστοποίηση του χρόνου εκτέλεσης, καθώς παρατηρούμε σταδιακή μείωση του CPI.
Βασική παράμετρος αποτελεί και το cache_line size, αφού για cache_line = 256Kb έχουμε βέλτιστη απόδοση CPI = 1.151575.

  Τέλος, για τα benchmarks 458 και 470, είναι ξεκάθαρο πως η σημαντικότερη παράμετρος που επηρεάζει το CPI είναι το cache_line size.
</pre>  <br>
 
     
     
     
<br><br>
## <pre>Bήμα 3)</pre>  

_<b><pre>Απόδοση κρυφής μνήμης</pre></b>_
<pre>  Η μέτρηση απόδοσης κρυφής μνήμης έχει καταστεί σημαντική τον τελευταίο καιρό, όπου η διαφορά 
ταχύτητας μεταξύ της απόδοσης της μνήμης και της απόδοσης του επεξεργαστή αυξάνεται εκθετικά. Η κρυφή 
μνήμη εισήχθη για να μειώσει αυτό το κενό ταχύτητας. Έτσι, γνωρίζοντας πόσο καλά η μνήμη cache είναι 
ικανή να γεφυρώσει αυτό το κενό στην ταχύτητα του επεξεργαστή και της μνήμης, είναι σημαντική, ειδικά 
στα συστήματα υψηλής απόδοσης. Το ποσοστό επιτυχίας (hit rate) και το ποσοστό αποτυχίας (missa rate) 
της μνήμης cache παίζουν σημαντικό ρόλο στον καθορισμό αυτής της απόδοσης. Για να βελτιωθεί η απόδοση 
της κρυφής μνήμης, η μείωση του ποσοστού θανάτου γίνεται ένα από τα απαραίτητα βήματα μεταξύ άλλων βημάτων.
Η μείωση του χρόνου πρόσβασης στη μνήμη cache δίνει επίσης ώθηση στην απόδοσή της.
  Ο χρόνος που απαιτείται για τη λήψη μιας γραμμής κρυφής μνήμης από τη μνήμη (καθυστέρηση εξαιτίας cache miss) 
έχει σημασία, διότι η CPU μένει χωρίς να εκτελεί κάποια εργασία ενώ περιμένει την κρυφή μνήμη. Όταν μια CPU 
φτάσει σε αυτήν την κατάσταση, ονομάζεται stall, δηλαδή καθυστέρηση, στάση. Καθώς οι επεξεργαστές γίνονται 
ταχύτεροι σε σύγκριση με την κύρια μνήμη, αυτές οι καθυστερήσεις που οφείλονται σε λάθη μνήμης cache 
περιορίζουν τις επεξεργαστικές δυνατότητες των CPUs. Οι σύγχρονοι επεξεργαστές CPU μπορούν να εκτελέσουν 
εκατοντάδες εντολές στον χρόνο που απαιτείται για την ανάκτηση μίας γραμμής μνήμης cache από την κύρια μνήμη.

Associativity
  Όσον αναφορά την επιλογή του αριθμού Associativity για τις διάφορες μνήμες cache υπάρχει μία σχέση "συμβιβασμού" (trade-off) που καλείται να λάβει υπόψην του ο σχεδιαστής, μία σχέση που δεν είναι πάντα τόσο εύκολο να αναλυθεί. Γενικά ένας μεγάλος αριθμός Αssocietivity έχει ώς βασικό πλεονέκτημα ότι χαρακτηρίζεται από λιγότερα misses, και άρα η CPU σπαταλάει λιγότερο χρόνο στο να διαβάζει δεδομένα από την κύρια μνήμη, η οποία είναι σημαντικά πιο αργή από την cache. Ωστόσο υπάρχουν και μερικά μειονεκτήματα για μεγάλο αριθμό Associativity, τα οποία είναι: Α) Μεγαλύτερο κόστος ενέργειας, Β) Απαίτηση για μεγαλύτερο χώρο πάνω στο ολοκληρωμένο και Γ) Μεγαλύτερος χρόνος αναζήτησης των ζητούμενων δεδομένων στην cache.
</pre>
<br><br><br>


## Κριτική
Σαν εργασία ήταν πολύ ενδιαφέρουσα. Είδαμε πως δουλεύουν οι μνήμες cache, l1 και l2 και κάποιες άλλες παράμετροι όπως το associativity και ήρθαμε σε μια πιο στενή επαφή με τα benchmarks και το πως αυτές οι παράμετροι επηρεάζουν την απόδοση τους (CPI). Ένα downside ήταν οι μεγάλοι χρόνοι που απαιτούνταν για την εκτέλεση των προσομοιώσεων, ειδικά σε Virtual machine (στον έναν υπολογιστή μας πήρε σχεδόν μια μέρα). Ήρθαμε σε επαφή με πιο πρακτικά πράγματα, πειραματιστήκαμε με διάφορες τιμές και combos, εργαστήκαμε στο terminal (κάτι που μας αρέσει) και ψάξαμε πληροφορίες για το πως λειτουργούν αυτές οι παράμετροι σε ένα πραγματικό σύστημα. Αυτό από μόνο του σου δίνει μια αίσθηση ικανοποίησης όταν τελικά τα πράγματα τρέχουν όπως θες. Επεκτείναμε τις γνώσεις μας σχετικά με τις προσομοιώσεις, τους επεξεργαστές και τις μνήμες, ακόμα και για την ωραιοποίηση του README! Βέβαια το πρόβλημα με το ανέβασμα των αρχείων στο github επιμένει, ειδικά τώρα που φτιάξαμε και πολλους φακέλους. Εν ολίγοις ήταν μια ευχάριστη, κατανοητή εργασία, που προσφερόταν για πολύ πειραματισμό, αλλά ταυτόχρονα ήταν πολύ χρονοβόρα και επίπονη για το σύστημα.

      
<b>_Βιβλιογραφία_<b>:  https://en.wikipedia.org/wiki/CPU_cache  
  https://cirosantilli.com/linux-kernel-module-cheat/?fbclid=IwAR3h1ny5hRoVUIGP1vtOsUAzqXYd69sHBAopwuveHZtTSbd_MFp0B4Nmp8c#gem5-cpu-types  
http://gem5.org/InOrder  
http://www.m5sim.org/SimpleCPU#BaseSimpleCPU  
http://www.gem5.org/docs/html/minor.html
