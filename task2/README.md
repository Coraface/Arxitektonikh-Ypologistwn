## Εργασία 2 - Φοιτητές: Χωραφάς Χρήστος(8718)/Φάββας Αντώνης(8675), Ομάδα 33

## <pre>Βήμα 1)</pre>  


<pre><b>Ερώτημα 1</b></pre>  <br>
  1. _`i_cache_size : 32768`_  
  2. _`i_cache_assoc : 2`_  
  3. _`d_cache_size : 65596`_  
  4. _`d_cache_assoc : 2`_  
  5. _`l2_size : 2097152`_    
  6. _`l2_assoc : 8`_    
  7. _`cache_line_size : 64`_  
  
   <pre> Παρατήρηση: Για όλα τα benchmarks οι τιμές των διαφόρων παραμέτρων είναι ίδιες (default τιμές).</pre>  

   
   <br><br> 
<pre><b>Ερώτημα 2</b></pre>  <br>
_Benchmark 401_:  
  1. _`sim_seconds : 0.082631`_  
  2. _`CPI : 1.652621`_  
  3. _`i_misses : 0.000051`_  
  4. _`d_misses : 0.015205`_  
  5. _`l2_misses : 0.281779`_    
    <br>
    
_Benchmark 429_:  
  1. _`sim_seconds : 0.120773`_  
  2. _`CPI : 1.207734`_  
  3. _`i_misses : 0.01037`_  
  4. _`d_misses : 0.001938`_  
  5. _`l2_misses : 0.110032`_    
    <br>
    
_Benchmark 456_:  
  1. _`sim_seconds : 0.058129`_  
  2. _`CPI : 1.162574`_  
  3. _`i_misses : 0.000186`_  
  4. _`d_misses : 0.001673`_  
  5. _`l2_misses : 0.086262`_    
    <br>
    
_Benchmark 458_:  
  1. _`sim_seconds : 0.514664`_  
  2. _`CPI : 10.293277`_  
  3. _`i_misses : 0.000019`_  
  4. _`d_misses : 0.122943`_  
  5. _`l2_misses : 0.999984`_    
    <br>
    
_Benchmark 470_:  
  1. _`sim_seconds : 0.174660`_  
  2. _`CPI : 3.493201`_  
  3. _`i_misses : 0.000103`_  
  4. _`d_misses : 0.060970`_  
  5. _`l2_misses : 0.999940`_  
    
    Περιγραφή: Γενικός κανόνας είναι ότι όταν έχουμε μεγάλο αριθμό Misses στις διάφορες μνήμες 
    (i_cache, d_cache, l2_cache) έχουμε και μεγάλο CPI, το οποίο συνεπάγεται σε χειρότερο (μεγαλύτερο) χρόνο εκτέλεσης 
    της προσομοίωσης του benchmark. Συγκεκριμένα στο παράδειγμα μας το benchmark 458 έχει μεγάλο αριθμό Misses, κάτι το οποίο 
    συνεπάγεται μεγάλο CPI και άρα μεγάλο χρόνο εκτέλεσης της προσομοίωσης. Αντίθετα, το benchmark 456 έχει 
    τον μικρότερο αριθμό Misses σε όλες τις μνήμες, και ως συνέπεια αυτού χαρακτηρίζεται από το μικρότερο CPI και άρα τον καλύτερο 
    (μικρότερο) χρόνο προσομοίωσης.
    
   <br><br>
<pre><b>Ερώτημα 3</b></pre>  <br>  

Για όλα τα benchmarks ισχύει:  
  1. _`--cpu-clock=2GHz : system.clock = 1000`_  
  2. _`--cpu-clock=2GHz : system.cpu.clock = 500`_ 
  3. _`--cpu-clock=1GHz : system.clock = 1000`_  
  4. _`--cpu-clock=1GHz : system.cpu.clock = 1000`_  
  
<pre>  Και στις 2 περιπτώσεις τα δίαφορα μέρη του συστήματος χρονίζονται στο 1GHz. Ωστόσο οι πυρήνες και οι 
διάφοροι επεξεργαστές που ενδεχομένως να προστεθούν στο σύστημα χρονίζονται στα 2GHz (Α περίπτωση) και 
στο 1GHz (Β περίπτωση) αντίστοιχα. Επαλήθευση αυτών των παρατηρήσεων αποτελούν αυτά τα κομμάτια κώδικα 
από το .json αρχείο (A περίπτωση) : 
  
  "name": "cpu_clk_domain",                               
            "clock": [
                500
            ],  

  "name": "clk_domain", 
            "clock": [
                1000
            ], </pre>
     
     
<pre>  Όσον αφορά το scaling πρέπει να αναφέρουμε ότι στις μικρές συχνότητες υπάρχει αρκετά καλό scaling. 
Ωστόστο όσο αυξάνουμε την συχνότητα του επεξεργαστή τόσο μικραίνει ο ρυθμός με τον οποίο μειώνεται ο χρόνος
εκτέλεσης της προσομοίωσης. Αυτό συμβαίνει γιατι ο επεξεργαστής είναι συνήθως αρκετά πιο γρήγορος απο τα 
υπόλοιπα στοιχεία του συστήματος, συνεπώς αναγκάζεται να περιμένει. Στα πλαίσια αυτής της λογικής, ένας 
επεξεργαστής των 8GHz δεν σημαίνει ότι θα έτρεχε στο μισό χρόνο το ίδιο πρόγραμμα, που θα έτρεχε ένας άλλος 
επεξεργαστής των 4GHz. Άρα δεν υπάρχει τέλειο scaling.</pre>
   <br><br>  
     
## <pre>Bήμα 2)</pre>  

<pre>  Τα γραφήματα υπάρχουν στον φάκελο task2/graphs. Στα διάφορα γραφήματα ο άξονας των x παρέχει μια 
εικονική αρίθμηση, καθώς οι τιμές του αξονα αυτού για κάθε καμπύλη του γραφήματος είναι διαφορετικές. 
Αναλυτικότερα, για το l1i_size και l1d_size, οι τιμές για x = 1 μέχρι x = 8 αντιστοίζονται σε τιμές απο 
2 μεχρι 256Kb. Επιπλέον, για τα l1i_assoc, l1d_assoc και l2_assoc οι τιμές x = 1 μέχρι x = 5 αντιστοιχίζονται
σε τιμές απο 1 μέχρι 16. Ακόμα, για το l2_size οι τιμές του άξονα x αντιστοιχίζονται από 2 μέχρι 4096Kb και όσον 
αφορά την τελευταία παράμετρο cache_line οι τιμές του x άξονα αντιστοιχίζονται από 32 μέχρι 1024Kb. 
  
  Για το benchmark 401 οι μεταβλητές που παίζουν σημαντικό ρόλο στην ελαχιστοποίηση του CPI 
είναι το l2_size και το l1d_size, για το οποίο μάλιστα έχουμε και το ελάχιστο CPI 
(βέλτιση απόδοση CPI = 1.589011). 

  Για το benchmark 429 μέσα από το αρχείο stats.txt παρατηρούμε ότι όσο αυξάνεται το l1i_size τόσο 
μειώνεται το i_miss rate και τόσο μικρότερο CPI έχουμε. Το ίδιο ακριβώς ισχύει και για l1d_size. Επίσης 
βλέπουμε ότι βέλτιστη απόδοση CPI = 1.080834 δίνει το cache_line = 256Kb και άρα τελικά και οι τρεις 
μεταβλητές διαδραματίζουν σημαντικό ρόλο στην απόδοση του συστήματος.

  Για το benchmark 456 η αύξηση των l1i_size, l1d_size και l2_size έχει ως αποτέλεσμα την μείωση του 
ποσοστού miss rate σε αυτές και την βελτιστοποίηση του χρόνου εκτέλεσης, καθώς παρατηρούμε σταδιακή μείωση του CPI.
Βασική παράμετρος αποτελεί και το cache_line size, αφού για cache_line = 256Kb έχουμε βέλτιστη απόδοση CPI = 1.151575.

  Τέλος, για τα benchmarks 458 και 470, η σημαντικότερη παράμετρος που επηράζει το CPI είναι το cache_line size.
</pre>  <br>
 
     
     
     
<br><br>
## <pre>Bήμα 3)</pre>  

_<b><pre>Απόδοση κρυφής μνήμης</pre></b>_
<pre>Η μέτρηση απόδοσης κρυφής μνήμης έχει καταστεί σημαντική τον τελευταίο καιρό, όπου η διαφορά 
ταχύτητας μεταξύ της απόδοσης της μνήμης και της απόδοσης του επεξεργαστή αυξάνεται εκθετικά. Η κρυφή 
μνήμη εισήχθη για να μειώσει αυτό το κενό ταχύτητας. Έτσι, γνωρίζοντας πόσο καλά η μνήμη cache είναι 
ικανή να γεφυρώσει αυτό το κενό στην ταχύτητα του επεξεργαστή και της μνήμης, είναι σημαντική, ειδικά 
στα συστήματα υψηλής απόδοσης. Το ποσοστό επιτυχίας (hit rate) και το ποσοστό αποτυχίας (missa rate) 
της μνήμης cache παίζουν σημαντικό ρόλο στον καθορισμό αυτής της απόδοσης. Για να βελτιωθεί η απόδοση 
της κρυφής μνήμης, η μείωση του ποσοστού θανάτου γίνεται ένα από τα απαραίτητα βήματα μεταξύ άλλων βημάτων.
Η μείωση του χρόνου πρόσβασης στη μνήμη cache δίνει επίσης ώθηση στην απόδοσή της.
  Ο χρόνος που απαιτείται για τη λήψη μιας γραμμής κρυφής μνήμης από τη μνήμη (καθυστέρηση εξαιτίας cache miss) 
έχει σημασία, διότι η CPU μένει χωρίς να εκτελεί κάποια εργασία ενώ περιμένει την κρυφή μνήμη. Όταν μια CPU 
φτάσει σε αυτήν την κατάσταση, ονομάζεται stall, δηλαδή καθυστέρηση, στάση. Καθώς οι επεξεργαστές γίνονται 
ταχύτεροι σε σύγκριση με την κύρια μνήμη, αυτές οι καθυστερήσεις που οφείλονται σε λάθη μνήμης cache 
περιορίζουν τις επεξεργαστικές δυνατότητες των CPUs. Οι σύγχρονοι επεξεργαστές CPU μπορούν να εκτελέσουν 
εκατοντάδες εντολές στον χρόνο που απαιτείται για την ανάκτηση μίας γραμμής μνήμης cache από την κύρια μνήμη.

Associativity
  Η επιλογή της σωστής τιμής του associativity συνεπάγεται ένα trade-off. Εάν υπάρχουν δέκα θέσεις στις 
οποίες η πολιτική τοποθέτησης θα μπορούσε να έχει χαρτογραφήσει μια θέση μνήμης, τότε για να ελέγξετε 
αν αυτή η θέση βρίσκεται στην προσωρινή μνήμη, θα πρέπει να αναζητηθούν δέκα εγγραφές cache. Ο έλεγχος 
περισσότερων θέσεων απαιτεί περισσότερη ισχύ και χώρο τσιπ, και ενδεχομένως περισσότερο χρόνο. Από την 
άλλη πλευρά, οι σφαίρες με περισσότερη συσχετισμό υφίστανται λιγότερες αποτυχίες, έτσι ώστε η CPU να 
σπαταλά λιγότερο χρόνο ανάγνωσης από την αργή κύρια μνήμη. Η γενική κατευθυντήρια γραμμή είναι ότι ο 
διπλασιασμός της συσχέτισης, από την άμεση χαρτογράφηση στην αμφίδρομη ή από την αμφίδρομη στην τετραπλή, 
έχει περίπου το ίδιο αποτέλεσμα στην αύξηση του ποσοστού επιτυχίας διπλασιάζοντας το μέγεθος της κρυφής 
μνήμης. Ωστόσο, η αυξανόμενη συσχέτιση περισσότερο από τέσσερα δεν βελτιώνει το ποσοστό επιτυχίας τόσο 
και γενικά γίνονται για άλλους λόγους (βλ. εικονική ψευδώνυμο, παρακάτω). Ορισμένες CPU μπορούν να 
μειώσουν δυναμικά τη συσχέτιση των κρυφών μνήμων τους σε καταστάσεις χαμηλής ισχύος, πράγμα που ενεργεί 
ως μέτρο εξοικονόμησης ενέργειας. 
</pre>
<br><br><br>


## Κριτική
Σαν εργασία ήταν πολύ ενδιαφέρουσα. Ήρθαμε σε επαφή με πιο πρακτικά πράγματα, εργαστήκαμε στο terminal (κάτι που μας αρέσει) και ψάξαμε πληροφορίες για το πως να αλλάξουμε παραμέτρους στα commands. Αυτό από μόνο του σου δίνει μια αίσθηση ικανοποίησης όταν τελικά τα πράγματα τρέχουν όπως θες. Μάθαμε αρκετά για τις προσομοιώσεις, τους επεξεργαστές και τις μνήμες, ακόμα και για την ωραιοποίηση του README χρησιμοποιώντας Markdown. Συναντήσαμε ένα μικρό πρόβλημα με το ανέβασμα των αρχείων, εφόσον μετά είδαμε ότι χρειάζονται όλες οι μετρήσεις και έπρεπε να ξανατρέξουμε τις αντίστοιχες εντολές, όπως και με το γεγονός ότι δεν υπήρχαν αρκετές πληροφορίες στο ίντερνετ για InOrder Cpu. Εν ολίγοις ήταν μια ευχάριστη, όχι πολύ δύσκολη εργασία που κάλυπτε αρκετά πράγματα.

      
<b>_Βιβλιογραφία_<b>:  https://en.wikipedia.org/wiki/CPU_cache  
  https://cirosantilli.com/linux-kernel-module-cheat/?fbclid=IwAR3h1ny5hRoVUIGP1vtOsUAzqXYd69sHBAopwuveHZtTSbd_MFp0B4Nmp8c#gem5-cpu-types  
http://gem5.org/InOrder  
http://www.m5sim.org/SimpleCPU#BaseSimpleCPU  
http://www.gem5.org/docs/html/minor.html
