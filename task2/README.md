## Εργασία 2 - Φοιτητές: Χωραφάς Χρήστος(8718)/Φάββας Αντώνης(8675), Ομάδα 33

## <pre>Βήμα 1)</pre>  


<pre><b>Ερώτημα 1</b></pre>  <br>
  1. _`i_cache_size : 32768`_  
  2. _`i_cache_assoc : 2`_  
  3. _`d_cache_size : 65596`_  
  4. _`d_cache_assoc : 2`_  
  5. _`l2_size : 2097152`_    
  6. _`l2_assoc : 8`_    
  7. _`cache_line_size : 64`_  
  
   <pre> Παρατήρηση: Για όλα τα benchmarks οι τιμές των διαφόρων παραμέτρων είναι ίδιες (default τιμές).</pre>  

   
   <br><br> 
<pre><b>Ερώτημα 2</b></pre>  <br>
_Benchmark 401_:  
  1. _`sim_seconds : 0.082631`_  
  2. _`CPI : 1.652621`_  
  3. _`i_misses : 0.000051`_  
  4. _`d_misses : 0.015205`_  
  5. _`l2_misses : 0.281779`_    
    <br>
    
_Benchmark 429_:  
  1. _`sim_seconds : 0.120773`_  
  2. _`CPI : 1.207734`_  
  3. _`i_misses : 0.01037`_  
  4. _`d_misses : 0.001938`_  
  5. _`l2_misses : 0.110032`_    
    <br>
    
_Benchmark 456_:  
  1. _`sim_seconds : 0.058129`_  
  2. _`CPI : 1.162574`_  
  3. _`i_misses : 0.000186`_  
  4. _`d_misses : 0.001673`_  
  5. _`l2_misses : 0.086262`_    
    <br>
    
_Benchmark 458_:  
  1. _`sim_seconds : 0.514664`_  
  2. _`CPI : 10.293277`_  
  3. _`i_misses : 0.000019`_  
  4. _`d_misses : 0.122943`_  
  5. _`l2_misses : 0.999984`_    
    <br>
    
_Benchmark 470_:  
  1. _`sim_seconds : 0.174660`_  
  2. _`CPI : 3.493201`_  
  3. _`i_misses : 0.000103`_  
  4. _`d_misses : 0.060970`_  
  5. _`l2_misses : 0.999940`_  
    
    Περιγραφή: Γενικός κανόνας είναι ότι όταν έχουμε μεγάλο αριθμό Misses στις διάφορες μνήμες 
    (i_cache, d_cache, l2_cache) έχουμε και μεγάλο CPI, το οποίο συνεπάγεται σε χειρότερο (μεγαλύτερο) χρόνο εκτέλεσης 
    της προσομοίωσης του benchmark. Συγκεκριμένα στο παράδειγμα μας το benchmark 458 έχει μεγάλο αριθμό Misses, κάτι το οποίο 
    συνεπάγεται μεγάλο CPI και άρα μεγάλο χρόνο εκτέλεσης της προσομοίωσης. Αντίθετα, το benchmark 456 έχει 
    τον μικρότερο αριθμό Misses σε όλες τις μνήμες, και ως συνέπεια αυτού χαρακτηρίζεται από το μικρότερο CPI και άρα τον καλύτερο 
    (μικρότερο) χρόνο προσομοίωσης.
    
   <br><br>
<pre><b>Ερώτημα 3</b></pre>  <br>  

Για όλα τα benchmarks ισχύει:  
  1. _`--cpu-clock=2GHz : system.clock = 1000`_  
  2. _`--cpu-clock=2GHz : system.cpu.clock = 500`_ 
  3. _`--cpu-clock=1GHz : system.clock = 1000`_  
  4. _`--cpu-clock=1GHz : system.cpu.clock = 1000`_  
  
<pre>Και στις 2 περιπτώσεις τα δίαφορα μέρη του συστήματος χρονίζονται στο 1GHz. Ωστόσο οι πυρήνες και οι 
διάφοροι επεξεργαστές που ενδεχομένως να προστεθούν στο σύστημα χρονίζονται στα 2GHz (Α περίπτωση) και 
στο 1GHz (Β περίπτωση) αντίστοιχα. Επαλήθευση αυτών των παρατηρήσεων αποτελούν αυτά τα κομμάτια κώδικα 
από το .json αρχείο (A περίπτωση) : 
  
  "name": "cpu_clk_domain",                               
            "clock": [
                500
            ],  

  "name": "clk_domain", 
            "clock": [
                1000
            ], </pre>
     
     
  <pre>Όσον αφορά το scaling πρέπει να αναφέρουμε ότι στις μικρές συχνότητες υπάρχει αρκετά καλό scaling. 
Ωστόστο όσο αυξάνουμε την συχνότητα του επεξεργαστή τόσο μικραίνει ο ρυθμός με τον οποίο μειώνεται ο χρόνος
εκτέλεσης της προσομοίωσης. Αυτό συμβαίνει γιατι ο επεξεργαστής είναι συνήθως αρκετά πιο γρήγορος απο τα 
υπόλοιπα στοιχεία του συστήματος, συνεπώς αναγκάζεται να περιμένει. Στα πλαίσια αυτής της λογικής, ένας 
επεξεργαστής των 8GHz δεν σημαίνει ότι θα έτρεχε στο μισό χρόνο το ίδιο πρόγραμμα, που θα έτρεχε ένας άλλος 
επεξεργαστής των 4GHz. Άρα δεν υπάρχει τέλειο scaling.</pre>
   <br><br>  
     
## <pre>Bήμα 2)</pre>  

<pre><b>Ερώτημα 1</b></pre>  <br>
     
     
     
<br><br>
## <pre>Bήμα 3)</pre>  

_<b><pre>Απόδοση κρυφής μνήμης</pre></b>_
<pre>Η μέτρηση απόδοσης κρυφής μνήμης έχει καταστεί σημαντική τον τελευταίο καιρό, όπου η διαφορά 
ταχύτητας μεταξύ της απόδοσης της μνήμης και της απόδοσης του επεξεργαστή αυξάνεται εκθετικά. Η κρυφή 
μνήμη εισήχθη για να μειώσει αυτό το κενό ταχύτητας. Έτσι, γνωρίζοντας πόσο καλά η μνήμη cache είναι 
ικανή να γεφυρώσει αυτό το κενό στην ταχύτητα του επεξεργαστή και της μνήμης, είναι σημαντική, ειδικά 
στα συστήματα υψηλής απόδοσης. Το ποσοστό επιτυχίας (hit rate) και το ποσοστό αποτυχίας (missa rate) 
της μνήμης cache παίζουν σημαντικό ρόλο στον καθορισμό αυτής της απόδοσης. Για να βελτιωθεί η απόδοση 
της κρυφής μνήμης, η μείωση του ποσοστού θανάτου γίνεται ένα από τα απαραίτητα βήματα μεταξύ άλλων βημάτων.
Η μείωση του χρόνου πρόσβασης στη μνήμη cache δίνει επίσης ώθηση στην απόδοσή της.
  Ο χρόνος που απαιτείται για τη λήψη μιας γραμμής κρυφής μνήμης από τη μνήμη (καθυστέρηση εξαιτίας cache miss) 
έχει σημασία, διότι η CPU μένει χωρίς να εκτελεί κάποια εργασία ενώ περιμένει την κρυφή μνήμη. Όταν μια CPU 
φτάσει σε αυτήν την κατάσταση, ονομάζεται stall, δηλαδή καθυστέρηση, στάση. Καθώς οι επεξεργαστές γίνονται 
ταχύτεροι σε σύγκριση με την κύρια μνήμη, αυτές οι καθυστερήσεις που οφείλονται σε λάθη μνήμης cache 
περιορίζουν τις επεξεργαστικές δυνατότητες των CPUs. Οι σύγχρονοι επεξεργαστές CPU μπορούν να εκτελέσουν 
εκατοντάδες εντολές στον χρόνο που απαιτείται για την ανάκτηση μίας γραμμής μνήμης cache από την κύρια μνήμη.
</pre>
<br><br><br>


## Κριτική
Σαν εργασία ήταν πολύ ενδιαφέρουσα. Ήρθαμε σε επαφή με πιο πρακτικά πράγματα, εργαστήκαμε στο terminal (κάτι που μας αρέσει) και ψάξαμε πληροφορίες για το πως να αλλάξουμε παραμέτρους στα commands. Αυτό από μόνο του σου δίνει μια αίσθηση ικανοποίησης όταν τελικά τα πράγματα τρέχουν όπως θες. Μάθαμε αρκετά για τις προσομοιώσεις, τους επεξεργαστές και τις μνήμες, ακόμα και για την ωραιοποίηση του README χρησιμοποιώντας Markdown. Συναντήσαμε ένα μικρό πρόβλημα με το ανέβασμα των αρχείων, εφόσον μετά είδαμε ότι χρειάζονται όλες οι μετρήσεις και έπρεπε να ξανατρέξουμε τις αντίστοιχες εντολές, όπως και με το γεγονός ότι δεν υπήρχαν αρκετές πληροφορίες στο ίντερνετ για InOrder Cpu. Εν ολίγοις ήταν μια ευχάριστη, όχι πολύ δύσκολη εργασία που κάλυπτε αρκετά πράγματα.

      
<b>_Βιβλιογραφία_<b>:  https://en.wikipedia.org/wiki/CPU_cache  
  https://cirosantilli.com/linux-kernel-module-cheat/?fbclid=IwAR3h1ny5hRoVUIGP1vtOsUAzqXYd69sHBAopwuveHZtTSbd_MFp0B4Nmp8c#gem5-cpu-types  
http://gem5.org/InOrder  
http://www.m5sim.org/SimpleCPU#BaseSimpleCPU  
http://www.gem5.org/docs/html/minor.html
